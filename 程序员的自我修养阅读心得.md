# 程序员的自我修养阅读心得

## 温故而知新
第一章开头的几个问题中有个问题是main函数之前发生了什么？，main函数结束以后又发生了什么？在学习单片机的时候知道在mian函数之前需要初始化堆栈，设置中断向量表，设置系统时钟等一系列工作，但是没有想过main函数结束后发生了什么，因为在单片机代码的main函数中写了一个while循环。后来接触到linux的时候才逐渐接触到多进程的一些相关知识。

第一章里面作者介绍了分时系统、多任务系统（抢占式）等系统；分段、分页、进程、线程等等知识点。读到这些内容，又帮我复习一下相关的知识。这次“温故”让我“知新”了虚拟地址到物理地址的映射方法
**分段**：最开始引入的方式就是分段，通过把物理地址和虚拟地址的某一段对应起来，这样就解决了地址隔离的问题，因为程序A和程序B被映射到了两个不同得物理空间区域，他们之间没有任何重叠，如果程序A访问了超出它可以访问的范围，硬件就判定出错。另外还解决了运行地址不确定的问题，程序只需要关心固定的起始地址等，硬件会自动映射到物理内存上
**分页**：分段没有解决内存使用效率低的问题，因此引入了分页。分页的基本方法就是把地址空间人为地等分成固定大小的页，比如4KB。根据程序的局部性原理，每次程序真正使用到的其实只是整个程序中的一小部分，所以分页之后可以只加载正在使用和可能将要使用的那一部分内存。


* * *

## 编译和链接
在平常写代码的时候，只需要点击一下构建按钮就可以得到运行程序，也知道其中包含了预处理，编译，汇编和链接这几步过程，但是并没有深入了解这几个过程中到底发生了什么。看了这一章后才明白编译器默默地做了词法分析、语法分析、语义分析、中间语言生成和目标代码生成与优化等等一些列工作，只为将我们写的代码(说不定还有有bug??)翻译成机器能执行的语言。(突然想到当时在牛客网上刷字符串语义分割类的意义了），在点击构建按钮的过程中，发生了以下四个步骤：

* 预处理：主要处理源码中“#”开始的预编译指令。例如“#include”，“#define“等。
* 编   译：把前一步处理完的文件进行一系列的词法分析、语法分析、语义分析和优化产生汇编代码文件。
* 汇   编：将上一步骤生成的汇编代码转变成机器可以执行的指令。这里主要讲的是汇编原理
* 链   接：主要内容是把各个模块之间相互引用的部分处理好，使得各个模块之间能够正常的衔接。

看到静态链接部分的时候也回想过一个.c文件调用另外一个.c文件里面的函数或者全局变量时，它到底怎么知道这个函数或者变量的位置。然后在这一节讲解了从早期程序员用机器码写代码，到汇编语言再到高级语言才理解了链接的重要性，引用书中的一句话就是"极大地解放了生产力"。链接的主要内容就是把合个模块之间相互引用的部分处理好，使得合个模块之间能够正确的衔接。到这里知道了链接的重要性和作用，但是也有一些问题还是没有明白:链接的时候函数或者变量的空间与地址是怎么分配的？这些记录的信息是易什么样的形式保存的？希望后面章节可以解开疑惑。

* * *


## 目标文件里面有什么
这一章作者主要介绍了目标文件里面的组成部分以及每一部分记录的信息。正如书里面讲解的那样， 目标文件里面包含有：ELF头文件区域；代码区域；数据区域；等等区域。 各个区域以“段”（Segment）的形式分别存储。
**ELF头文件**：该部分存储了与目标平台相关的数据。例如：ELF魔法数，字节长度，存储方式等数据。
代码段：存储编译后的机器指令。一般称为”.code”或“.text”段。
**数据段**：存储全局变量和静态变量数据。一般称“.data”段。
**.bss 段**：为未初始化的全局变量和静态变量预留位置，不存储实际内容。为什么对这未初始化的数据新建立个区域呢？这就是设计者的巧妙：划分一个区域，存放这些未初始化的变量并且分配空间，但是不存放数据。由于这些变量的默认数据都是0。所以没有必要存放数据了。反正从这一块区域获取的变量数值都是0。
**.rodata 段**：存放只读数据。在该区域内一个典型的例子就是printf()用到的字符串常量“%d\n”，这样保证了不可修改性。
**自定义段**： 一般情况下，上述的段区域为程序对应好了相关的存储位置。但是有些情况下，自己写的变量或函数希望能够存放到自己所指定的段中去。这样就出现了“自定义段”。一般通过“__attribute__((section(“name”)))”属性就可以把变量或者函数存放到“name”作为段名的段中。
**“符号”段**：各个模块通过链接而拼装成一个可执行程序。所以拼装的规则是很重要的。 在链接过程中，目标文件的相互拼装，实际上是地址的相互引用。即对函数和变量地址的引用。例如main模块调用了fun1函数，而fun1函数在另外一个A模块中。要想main模块准确地调用了A模块的fun1函数，必须正确的引用到A模块fun1函数的地址。那如何来保证正确呢？同样的B模块也有一个fun1函数。那又怎么解决函数重名的问题呢？这个就需要对函数按模块按函数名称进行唯一标识。当然这个方式也适用于变量。总结这段意思：就是将函数和变量进行符号化，并且保证符号在全局范围内是唯一的。
保证符号唯一性一般有下面2个方法：

* 1.所有的符号名（函数或变量）前面加上“_”. 最典型的例子就是 C语言的 “_foo”。当然有些语言是前后都加“_”.例如“_foo_”.
* 2.对于大型项目来说，方式1不能满足需要，于是就出现了名称空间（Namespace）的方法解决多模块的符号冲突问题。例如C++语言中的Namaspace宏。

在这一章里面也解开了上一章留下来的一个疑问，就是在链接的时候会用到目标文件里面的重定位表、字符串表和符号表里面记录信息。代码里面每一个函数或者变量都会经过编译后形成对应的符号与符号值，其中这个符号值就是这个函数或者变量对应的地址。这所有的一切都是在为链接做准备。

* * *

## 静态链接
通过前面几章的铺垫，终于来到了静态链接部分。在第二章里面遗留的空间与地址分配问题在这里得到了解答。在链接时，将多个.o文件输出成一个可执行文件的时候采用相似段合并的方法。链接器空间分配的策略采用两步链接法:第一步 空间与地址分配，第二步 符号解析与重定位。其中第二步为链接过程的核心，特别是重定位过程。

**空间和地址的分配**：扫描所有的目标文件，获取各个段的长度和位置并把各个段合并在一起，同时还获取符号表中所有的函数定义和引用，并把他们合并到一个全局符号表中。然后针对合并之后的总段进行各个段的虚拟地址映射。从而实现段段空间和地址的分配。
       具体来说，a.o和b.o两个文件。扫描他们的.text，.data,.bss等等所有的段长度和位置，并合并成一个临时的c.o文件。这样有的目标文件的段信息就合并到一个文件了。同时函数名（符号）的定义和引用也统一到一个全局符号表中。然后对c.o文件中的段进行虚拟地址的映射。
这里在空间地址的分配方案一般有两种方案：

* 1.按序叠加，
* 2.相似段合并。

很显然采用第二种方案更加节省空间。

**符号（函数）解析和重定位**：根据上一步骤的信息，再对各个段进行符号解析和重定位，这里也包括数据的重定位。首先是符号地址的确定和解析。对于符号来说，它有一个基地址和偏移量，然后根据这两个数值可以确定符号的地址了。重定位，这个是非常重要的，简单来说是对符号的地址重新修正，使之指向真正的符号地址（ 根据以前的学习stm32经验,有点像定义芯片内部寄存器用的基地址+偏移地址的形式）。

通过上面两个步骤，就完成了整个链接过程。 至此，大概了解了静态链接整个过程。即目标文件在被链接成最终可执行文件时，输入目标文件中的各个段是如何被合并到输出文件中的，如何分配的空间与地址。通过符号的解析与重定位，把每个段中需要的重定位的指令和数据进行修正。

* * *

## 动态链接
前面部分已经了解了静态链接，虽然已经能够满足编译过程全部需求了，但是它也有两个致命的问题：空间浪费和更新困难。动态链接的基本思想是把程序安装模块拆分成各个相对独立部分，在程序运行时才会将它们链接在一起，形成一个完整程序，而不是像静态链接那样把所以的程序模块都链接成一个单独的可执行文件。
在 Linux 系统中， ELF 动态链接文件被称为动态共享对象（Dynamic Shared Objects）, 以 .so 为扩展名
在 Window 中，被称为动态链接库（Dynamic Linking Library）, 以 .dll 为扩展名
       共享对象的最终装载地址在编译时是不确定的，而是在装载时，装载器根据当前地址空间的空闲情况，动态分配一块足够大小的虚拟地址空间给相应的共享对象。动态链接的步骤和静态链接一样，也是先空间地址的分配，然后是符号解析和重定位。他们的不同之处是调用的时机调用对象不同。静态链接是在编译时期，而动态链接是在程序运行期间；静态链接是有个叫“ld”名称的静态链接器来完成， 而动态链接是由动态链接器完成的。对于动态链接器的流程一般是如下：
       首先动态链接器和普通的对象一样被加载并调用起来，只不过它比一般的动态对象（动态库）要早一些被调起来。在动态链接器被执行起来后，操作系统会把控制权交给动态链接器，然后由它来完成所有动态链接工作，在完成链接工作之后，再把控制权交还给系统，让系统继续执行其他操作。
共享对象在编译时不能假设自己在进程虚拟地址空间中的位置，在链接时，对所有绝对地址的引用不作重定位，而是把这一步推迟到装载时在完成。
装载时重定位是解决动态模块中有绝对地址引用的方法之一。 对于装载时重定位的方案，也有一个缺陷：装载的代码指令无法在多个进程共享，这样就失去了节省内存的优势。 而装载时重定位就不能解决这个问题。然后提出一个地址无关代码的技术
地址无关代码是指，程序模块中的指令部分在装载是不需要因为装载地址的改变而改变，所以实现的基本思想是把指令中那些需要被修改的部分分离出来，跟数据部分放在一起，这样指令部分可以保持不变，而数据部分可以在每个进程中拥有一个副本。
       动态链接也不是十分完美的，它有个比较大的问题就是性能问题。因为在运行期间，对模块进行空间地址分配，符号解析和重定位，这些操作都要耗时一些。动态链接比静态链接慢的原因：动态链接下对全局和静态的数据访问都要进行复杂的 GOT 定位，然后间接寻址；对于模块间的调用也要先定位 GOT， 然后再进行间接跳转动态链接的链接工作是在运行时完成。为了解决动态链接慢的问题，采取延迟绑定的方式。延迟绑定是当函数第一次用到时才进行并对（符号查找、重定位等），如果没有用到则不进行绑定。ELF 使用 PTL的方式来实现。

       至此，《程序员的自我修养》核心部分的阅读心得就记录到此了，非常有幸阅读了这本书，让我更加深入地学习了编译过程，链接的内部机制。了解地更加深入了，掌握的知识更加全面了，这也许是我读这本书的最大的收获。



